'use client';

import { useEffect, useRef, useCallback } from 'react';
import { LeadChatwit } from '../types';
import { toast } from "sonner";

interface SSEConnectionManagerProps {
  leads: LeadChatwit[];
  onLeadUpdate: (lead: LeadChatwit) => void;
}

export function SSEConnectionManager({ leads, onLeadUpdate }: SSEConnectionManagerProps) {
  const connectionsRef = useRef<Map<string, EventSource>>(new Map());
  const reconnectTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const isMountedRef = useRef(true);

  // Fun√ß√£o para criar conex√£o SSE individual
  const createSSEConnection = useCallback((leadId: string) => {
    console.log(`[SSE Manager] üîå Criando conex√£o SSE para lead: ${leadId}`);
    
    // Fechar conex√£o existente se houver
    const existingConnection = connectionsRef.current.get(leadId);
    if (existingConnection) {
      console.log(`[SSE Manager] üîÑ Fechando conex√£o existente para: ${leadId}`);
      existingConnection.close();
      connectionsRef.current.delete(leadId);
    }

    // Construir URL da conex√£o SSE
    const sseUrl = `/api/admin/leads-chatwit/notifications?leadId=${leadId}`;
    console.log(`[SSE Manager] üåê URL da conex√£o SSE: ${sseUrl}`);

    const eventSource = new EventSource(sseUrl);
    
    eventSource.onopen = () => {
      console.log(`[SSE Manager] ‚úÖ Conex√£o aberta para lead: ${leadId}`);
    };
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log(`[SSE Manager] üì® Notifica√ß√£o recebida para lead ${leadId}:`, data);
        
        if (data.type === 'error') {
          console.error(`[SSE Manager] ‚ùå Erro recebido via SSE:`, data.message);
          return;
        }
        
        if (data.type === 'connected') {
          console.log(`[SSE Manager] üéâ Confirma√ß√£o de conex√£o recebida para: ${leadId}`);
          return;
        }
        
        // Tratar estrutura correta da notifica√ß√£o
        const notificationData = data.data || data; // Compatibilidade com ambas estruturas
        
        if (notificationData.type === 'leadUpdate' && notificationData.leadData) {
          console.log(`[SSE Manager] üîÑ Atualizando lead ${leadId} com dados:`, notificationData.leadData);
          onLeadUpdate(notificationData.leadData);
          
          // üéâ Feedback visual melhorado com toast de sucesso
          const leadName = notificationData.leadData.name || notificationData.leadData.nome || 'Lead';
          
          // üîç Debug detalhado para identificar o tipo de processamento
          console.log(`[SSE Manager] üîç Debug toast - Lead: ${leadName}`, {
            manuscritoProcessado: notificationData.leadData.manuscritoProcessado,
            aguardandoManuscrito: notificationData.leadData.aguardandoManuscrito,
            espelhoProcessado: notificationData.leadData.espelhoProcessado,
            aguardandoEspelho: notificationData.leadData.aguardandoEspelho,
            analiseProcessada: notificationData.leadData.analiseProcessada,
            aguardandoAnalise: notificationData.leadData.aguardandoAnalise,
            message: notificationData.message
          });
          
          // üéØ Determinar o tipo de processamento baseado na mensagem do worker
          const isManuscritoUpdate = notificationData.message?.includes('manuscrito');
          const isEspelhoUpdate = notificationData.message?.includes('espelho');
          const isAnaliseUpdate = notificationData.message?.includes('an√°lise') || notificationData.message?.includes('pr√©-an√°lise');
          
          console.log(`[SSE Manager] üîç Tipo de update detectado:`, {
            isManuscritoUpdate,
            isEspelhoUpdate, 
            isAnaliseUpdate,
            originalMessage: notificationData.message
          });
          
          // Verificar an√°lise primeiro (baseado na mensagem)
          if (isAnaliseUpdate && notificationData.leadData.analiseProcessada && !notificationData.leadData.aguardandoAnalise) {
            // Verificar se √© an√°lise preliminar ou final
            const isAnalisePreliminar = notificationData.leadData.analisePreliminar && !notificationData.leadData.analiseUrl;
            const title = isAnalisePreliminar 
              ? `üìã Pr√©-an√°lise de "${leadName}" processada!`
              : `üìä An√°lise de "${leadName}" processada!`;
            const description = isAnalisePreliminar
              ? "A pr√©-an√°lise foi conclu√≠da e est√° dispon√≠vel para consulta."
              : "A an√°lise foi conclu√≠da e os resultados est√£o dispon√≠veis.";
            
            toast(title, {
              description,
              duration: 8000,
            });
          } else if (isEspelhoUpdate && notificationData.leadData.espelhoProcessado && !notificationData.leadData.aguardandoEspelho) {
            toast(`üìã Espelho de "${leadName}" processado!`, {
              description: "A corre√ß√£o foi finalizada e est√° dispon√≠vel para consulta.",
              duration: 8000,
            });
          } else if (isManuscritoUpdate && notificationData.leadData.manuscritoProcessado && !notificationData.leadData.aguardandoManuscrito) {
            toast(`üéâ Manuscrito de "${leadName}" processado!`, {
              description: "O texto foi extra√≠do e est√° dispon√≠vel para visualiza√ß√£o.",
              duration: 20000,
              action: {
                label: 'Destacar Lead',
                onClick: () => {
                  console.log('üî• Bot√£o "Destacar Lead" clicado!');
                  console.log('üìç Lead ID:', leadId);
                  
                  // Disparar evento para destacar o lead na lista
                  const highlightEvent = new CustomEvent('highlightLead', {
                    detail: { leadId: leadId }
                  });
                  
                  console.log('üì° Disparando evento highlightLead:', highlightEvent.detail);
                  window.dispatchEvent(highlightEvent);
                }
              },
            });
          }
        }
      } catch (error) {
        console.error(`[SSE Manager] ‚ùå Erro ao processar notifica√ß√£o para ${leadId}:`, error);
      }
    };
    
    eventSource.onerror = (error) => {
      console.error(`[SSE Manager] ‚ùå Erro na conex√£o SSE para ${leadId}:`, error);
      console.log(`[SSE Manager] üîç Estado da conex√£o:`, {
        readyState: eventSource.readyState,
        url: eventSource.url,
        withCredentials: eventSource.withCredentials
      });
      
      // Tentar reconectar ap√≥s 5 segundos se ainda montado
      if (isMountedRef.current) {
        const timeout = setTimeout(() => {
          if (isMountedRef.current && connectionsRef.current.has(leadId)) {
            console.log(`[SSE Manager] üîÑ Tentando reconectar para: ${leadId}`);
            createSSEConnection(leadId);
          }
        }, 5000);
        
        reconnectTimeoutsRef.current.set(leadId, timeout);
      }
    };
    
    connectionsRef.current.set(leadId, eventSource);
  }, [onLeadUpdate]);

  // Fun√ß√£o para for√ßar reconex√£o de um lead espec√≠fico  
  const forceReconnectLead = useCallback((leadId: string, reason?: string) => {
    console.log(`[SSE Manager] üî• For√ßando reconex√£o para lead: ${leadId} (motivo: ${reason})`);
    createSSEConnection(leadId);
  }, [createSSEConnection]);

  // Limpar todas as conex√µes
  const cleanupAllConnections = useCallback(() => {
    console.log(`[SSE Manager] üßπ Limpando todas as conex√µes...`);
    
    // Fechar todas as conex√µes
    connectionsRef.current.forEach((connection, leadId) => {
      console.log(`[SSE Manager] üîå Fechando conex√£o para: ${leadId}`);
      connection.close();
    });
    connectionsRef.current.clear();
    
    // Limpar timeouts de reconex√£o
    reconnectTimeoutsRef.current.forEach(timeout => clearTimeout(timeout));
    reconnectTimeoutsRef.current.clear();
  }, []);

  // Atualizar conex√µes baseado nos leads
  const updateConnections = useCallback(() => {
    if (!isMountedRef.current) return;
    
    console.log(`[SSE Manager] üîç Verificando ${leads.length} leads total`);
    
    const leadsNeedingSSE = leads.filter(lead => 
      lead.aguardandoManuscrito || lead.aguardandoEspelho || lead.aguardandoAnalise
    );
    
    console.log(`[SSE Manager] üìä Total de ${leadsNeedingSSE.length} leads precisando SSE:`, 
      leadsNeedingSSE.map(l => ({ 
        id: l.id, 
        nome: l.nome || l.name,
        aguardandoManuscrito: l.aguardandoManuscrito, 
        aguardandoEspelho: l.aguardandoEspelho, 
        aguardandoAnalise: l.aguardandoAnalise 
      })));
    
    // Leads atualmente conectados
    const currentConnections = new Set(connectionsRef.current.keys());
    console.log(`[SSE Manager] üìã Conex√µes atuais:`, Array.from(currentConnections));
    
    // Leads que precisam de conex√£o
    const leadsNeeding = new Set(leadsNeedingSSE.map(lead => lead.id));
    console.log(`[SSE Manager] üìã Todos os leads (debug):`, 
      leads.map(l => ({ 
        id: l.id, 
        nome: l.nome || l.name,
        aguardandoManuscrito: l.aguardandoManuscrito, 
        aguardandoEspelho: l.aguardandoEspelho, 
        aguardandoAnalise: l.aguardandoAnalise,
        manuscritoProcessado: l.manuscritoProcessado,
        espelhoProcessado: l.espelhoProcessado,
        analiseProcessada: l.analiseProcessada
      })));
    
    // Remover conex√µes desnecess√°rias
    for (const leadId of currentConnections) {
      if (!leadsNeeding.has(leadId)) {
        console.log(`[SSE Manager] ‚ùå Removendo conex√£o desnecess√°ria para: ${leadId}`);
        const connection = connectionsRef.current.get(leadId);
        if (connection) {
          connection.close();
          connectionsRef.current.delete(leadId);
        }
      }
    }
    
    // Criar novas conex√µes necess√°rias
    for (const leadId of leadsNeeding) {
      if (!currentConnections.has(leadId)) {
        console.log(`[SSE Manager] üÜï Criando nova conex√£o para: ${leadId}`);
        createSSEConnection(leadId);
      } else {
        console.log(`[SSE Manager] ‚úÖ Conex√£o j√° existe para: ${leadId}`);
      }
    }
  }, [leads, createSSEConnection]);

  // Listener para evento de reconex√£o for√ßada
  useEffect(() => {
    const handleForceReconnect = (event: CustomEvent) => {
      const { leadId, reason } = event.detail;
      if (leadId) {
        console.log(`[SSE Manager] üéØ Recebido evento de reconex√£o for√ßada para: ${leadId} (${reason})`);
        forceReconnectLead(leadId, reason);
      }
    };

    window.addEventListener('force-sse-reconnect', handleForceReconnect as EventListener);
    
    return () => {
      window.removeEventListener('force-sse-reconnect', handleForceReconnect as EventListener);
    };
  }, [forceReconnectLead]);

  // Effect principal - atualizar conex√µes quando leads mudam
  useEffect(() => {
    updateConnections();
  }, [updateConnections]);

  // Cleanup no unmount
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
      cleanupAllConnections();
    };
  }, [cleanupAllConnections]);

  // Renderizar apenas se houver leads aguardando processamento
  const leadsAguardando = leads.filter(lead => 
    lead.aguardandoManuscrito || lead.aguardandoEspelho || lead.aguardandoAnalise
  );

  if (leadsAguardando.length === 0) {
    return null;
  }

  return (
    <div className="fixed bottom-4 right-4 z-50">
      <div className="bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border rounded-lg p-3 shadow-lg">
        <div className="flex items-center gap-2 text-sm">
          <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
          <span className="text-muted-foreground">
            {leadsAguardando.length} lead{leadsAguardando.length !== 1 ? 's' : ''} aguardando processamento
          </span>
        </div>
      </div>
    </div>
  );
} 